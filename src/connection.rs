use crate::frame::{self, Frame};

use bytes::{Buf, BytesMut};
use std::io::{self, Cursor};
use tokio::io::{AsyncReadExt, AsyncWriteExt, BufWriter};
use tokio::net::TcpStream;

/// Отправляет и получает значения `Frame` от сервера.
///
/// При реализации сетевых протоколов, сообщение протокола (protocol message)
/// часто состоит из нескольких меньших сообщений - кадров (frames). Цель
/// `Connection` - читать и записывать кадры в `TcpStream`.
///
/// Для чтения кадров `Connection` использует внутренний буфер, который заполняется
/// до тех пор, пока в нем не окажется достаточно байтов для создания полного кадра. Как только это произошло,
/// `Connection` создает кадр и возвращает его вызывающей стороне.
///
/// При отправке кадров, кадр сначала кодируется в буфер для записи.
/// Содержимое буфера для записи затем записывается в сокет.
#[derive(Debug)]
pub struct Connection {
    // `TcpStream` декорируется с помощью `BufWriter`, который предоставляет буфер
    // для записи. Реализация `BufWriter`, предоставляемая Tokio,
    // достаточна для наших нужд.
    stream: BufWriter<TcpStream>,

    // Буфер для чтения кадров.
    buffer: BytesMut,
}

impl Connection {
    /// Создает новый `Connection`, поддерживаемый `socket`.
    /// Инициализируются буферы для чтения и записи
    pub fn new(socket: TcpStream) -> Connection {
        Connection {
            stream: BufWriter::new(socket),
            // Дефолтный 4 КБ буфер для чтения. Для целей `mini-redis`
            // этого достаточно. Размер буфера в реальных приложениях
            // будет зависеть от их нужд. Высока вероятность, что
            // буфер большего размера будет работать лучше.
            buffer: BytesMut::with_capacity(4 * 1024),
        }
    }

    /// Читает значение `Frame` из потока.
    ///
    /// Функция ждет достаточного количества данных для разбора кадра.
    /// Любые данные, оставшиеся в буфере для чтения после разбора кадра,
    /// хранятся в нем до следующего вызова `read_frame`.
    ///
    /// # Возвращаемые значения
    ///
    /// При успехе возвращается полученный кадр. Если `TcpStream`
    /// закрыт способом, который не нарушает целостность кадра, возвращается
    /// `None`. Иначе, возвращается ошибка.
    pub async fn read_frame(&mut self) -> crate::Result<Option<Frame>> {
        loop {
            // Пытаемся разобрать кадр из данных буфера. Если в буфере
            // достаточно данных, возвращается кадр.
            if let Some(frame) = self.parse_frame()? {
                return Ok(Some(frame));
            }

            // В буфере недостаточно данных для чтения кадра.
            // Пытаемся прочитать больше данных из сокета.
            //
            // При успехе возвращается количество байтов. `0` означает
            // "конец потока"
            if 0 == self.stream.read_buf(&mut self.buffer).await? {
                // Сервер закрыл соединение. Для чистого закрытия
                // в буфере для чтения не должно оставаться данных.
                // Если такие данные имеются, значит сервер закрыл сокет
                // во время отправки кадра.
                if self.buffer.is_empty() {
                    return Ok(None);
                } else {
                    return Err("connection reset by peer".into());
                }
            }
        }
    }

    /// Пытается разобрать кадр из буфера. Если буфер содержит достаточное
    /// количество данных, кадр возвращается, и данные удаляются из буфера.
    /// Если данных недостаточно, возвращается `Ok(None)`.
    /// Если данные представляют невалидный кадр, возвращается `Err`
    fn parse_frame(&mut self) -> crate::Result<Option<Frame>> {
        use frame::Error::Incomplete;

        // `Cursor` используется для отслеживания "текущей" локации в буфере.
        // `Cursor` реализует `Buf` из крейта `bytes`, который
        // предоставляет набор полезных утилит для работы с байтами.
        let mut buf = Cursor::new(&self.buffer[..]);

        // Первый шаг - проверить, достаточно ли в буфере данных для разбора
        // кадра. Этот шаг обычно гораздо быстрее, чем полный разбор
        // кадра, и позволяет пропустить выделение структур данных
        // для хранения данных до получения всего кадра.
        match Frame::check(&mut buf) {
            Ok(_) => {
                // Функция `check` перемещает (advance) курсор в
                // конец кадра. Поскольку позиция курсора устанавливается в ноль
                // перед вызовом `Frame::check`, мы получаем длину
                // кадра путем проверки позиции курсора.
                let len = buf.position() as usize;

                // Сбрасываем позицию в ноль перед передачей курсора в
                // `Frame::parse`.
                buf.set_position(0);

                // Разбираем кадр из буфера. Это приводит к выделению необходимых структур
                // для представления кадра и возврату его значения.
                //
                // Если кодированное представление кадра является невалидным,
                // возвращается ошибка. Это должно приводить к закрытию текущего соединения,
                // но не должно влиять на других подключенных клиентов.
                let frame = Frame::parse(&mut buf)?;

                // Отбрасываем (discard) разобранные данные из буфера для чтения.
                //
                // При вызове `advance` на буфере для чтения, все данные
                // вплоть до `len` отбрасываются. За это отвечает
                // `BytesMut`. Часто это делается путем перемещения внутреннего
                // курсора, но это также может делаться путем повторного выделения и копирования данных.
                self.buffer.advance(len);

                // Возвращаем разобранный кадр вызывающей стороне.
                Ok(Some(frame))
            }
            // В буфере недостаточно данных для разбора кадра.
            // Нужно получить больше данных из сокета.
            // Чтение из сокета выполняется в инструкции после этого `match`.
            //
            // Здесь мы не хотим возвращать `Err`, поскольку эта "ошибка"
            // является ожидаемой.
            Err(Incomplete) => Ok(None),
            // При разборе кадра возникла ошибка. Соединение находится в
            // невалидном состоянии. Возврат `Err` отсюда приведет к
            // закрытию соединения.
            Err(e) => Err(e.into()),
        }
    }

    /// Записывает значение `Frame` в поток.
    ///
    /// Значение `Frame` записывается в сокет с помощью различных функций
    /// `write_*`, предоставляемых `AsyncWrite`. Вызывать эти функции прямо на
    /// `TcpStream` не рекомендуется, поскольку это приведет к большому количеству
    /// системных вызовов (syscalls). Эти функции лучше вызывать на буферизованном
    /// потоке для записи. Данные записываются в буфер. При заполнении
    /// буфера, данные передаются (flush) сокету.
    pub async fn write_frame(&mut self, frame: &Frame) -> io::Result<()> {
        // Массивы кодируются путем кодирования каждого элемента. Другие типы кадров
        // считаются литералами. `mini-redis` не умеет рекурсивно кодировать
        // вложенные структуры.
        match frame {
            Frame::Array(val) => {
                // Кодируем префикс типа кадра. Для массива таким префиксом является `*`.
                self.stream.write_u8(b'*').await?;

                // Кодируем длину массива.
                self.write_decimal(val.len() as u64).await?;

                // Перебираем и кодируем каждый элемент массива.
                for entry in &**val {
                    self.write_value(entry).await?;
                }
            }
            // Типом кадра является литерал. Кодируем значение.
            _ => self.write_value(frame).await?,
        }

        // Закодированный кадр должен быть записан в сокет.
        // Вызов `flush` записывает содержимое буфера в сокет.
        self.stream.flush().await
    }

    /// Записывает литерал кадра в поток.
    async fn write_value(&mut self, frame: &Frame) -> io::Result<()> {
        match frame {
            Frame::Simple(val) => {
                self.stream.write_u8(b'+').await?;
                self.stream.write_all(val.as_bytes()).await?;
                self.stream.write_all(b"\r\n").await?;
            }
            Frame::Error(val) => {
                self.stream.write_u8(b'-').await?;
                self.stream.write_all(val.as_bytes()).await?;
                self.stream.write_all(b"\r\n").await?;
            }
            Frame::Integer(val) => {
                self.stream.write_u8(b':').await?;
                self.write_decimal(*val).await?;
            }
            Frame::Null => {
                self.stream.write_all(b"$-1\r\n").await?;
            }
            Frame::Bulk(val) => {
                let len = val.len();

                self.stream.write_u8(b'$').await?;
                self.write_decimal(len as u64).await?;
                self.stream.write_all(val).await?;
                self.stream.write_all(b"\r\n").await?;
            }
            // Кодирование `Array` из значения не может быть выполнено рекурсивно.
            // В настоящее время асинхронные функции не поддерживают рекурсию.
            // `mini-redis` не поддерживает кодирование вложенных массивов.
            Frame::Array(_val) => unreachable!(),
        }

        Ok(())
    }

    /// Записывает десятичный кадр в поток.
    async fn write_decimal(&mut self, val: u64) -> io::Result<()> {
        use std::io::Write;

        // Преобразуем значение в строку.
        let mut buf = [0u8; 20];
        let mut buf = Cursor::new(&mut buf[..]);
        write!(&mut buf, "{}", val)?;

        let pos = buf.position() as usize;
        self.stream.write_all(&buf.get_ref()[..pos]).await?;
        self.stream.write_all(b"\r\n").await?;

        Ok(())
    }
}
